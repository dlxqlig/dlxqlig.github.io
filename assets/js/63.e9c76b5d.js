(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{635:function(a,r,v){a.exports=v.p+"assets/img/javavm-1.10ad3cd5.jpg"},742:function(a,r,v){"use strict";v.r(r);var t=v(4),s=Object(t.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("Java 虚拟机（JVM）是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能模拟来实现的。Java 虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。")]),a._v(" "),t("p",[t("img",{attrs:{src:v(635),alt:"1"}})]),a._v(" "),t("h2",{attrs:{id:"jvm内存模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存模型"}},[a._v("#")]),a._v(" JVM内存模型")]),a._v(" "),t("p",[a._v("Java 虚拟机（Java Virtual Machine=JVM）的内存空间分为五个部分，分别是：")]),a._v(" "),t("p",[a._v("程序计数器\nJava 虚拟机栈\n本地方法栈\n堆方法区")]),a._v(" "),t("h3",{attrs:{id:"程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),t("p",[a._v("程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。")]),a._v(" "),t("p",[a._v("程序计数器有两个作用：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n")])])]),t("h3",{attrs:{id:"java虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[a._v("#")]),a._v(" Java虚拟机栈")]),a._v(" "),t("p",[a._v("Java虚拟机栈是描述Java方法运行过程的内存模型。")]),a._v(" "),t("p",[a._v("Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("局部变量表 存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。\n操作数栈\n动态链接\n方法出口信息\n")])])]),t("p",[a._v("当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。")]),a._v(" "),t("p",[a._v("当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。")]),a._v(" "),t("p",[a._v("Java 虚拟机栈的特点：")]),a._v(" "),t("p",[a._v("（1）局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。")]),a._v(" "),t("p",[a._v("（2）Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。")]),a._v(" "),t("p",[a._v("a) StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。\nb) OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。\n（3）Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。")]),a._v(" "),t("h3",{attrs:{id:"本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),t("p",[a._v("本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n方法执行完毕后相应的栈帧也会出栈并释放内存空间。\n也会抛出StackOverFlowError和OutOfMemoryError异常。")]),a._v(" "),t("h2",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),t("p",[a._v("堆是用来存放对象的内存空间。 几乎所有的对象都存储在堆中。")]),a._v(" "),t("p",[a._v("堆的特点：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("（1）线程共享\n整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个的。\n（2）在虚拟机启动时创建。\n（3）垃圾回收的主要场所。\n（4）可以进一步细分为：新生代、老年代。\n新生代又可被分为：Eden、From Survior、To Survior。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。\n（5）堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出 OutOfMemoryError。\n")])])]),t("h2",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),t("p",[a._v("Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("线程共享 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。\n永久代 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。\n内存回收效率低 方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。\nJava虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。\n")])])]),t("h2",{attrs:{id:"结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[a._v("#")]),a._v(" 结论")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。\n\nJava虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。\n堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。\n\n程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法栈。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。\n")])])]),t("h2",{attrs:{id:"垃圾收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集"}},[a._v("#")]),a._v(" 垃圾收集")]),a._v(" "),t("h3",{attrs:{id:"minor-gc-和-full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc-和-full-gc"}},[a._v("#")]),a._v(" Minor GC 和 Full GC")]),a._v(" "),t("p",[a._v("Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\nFull GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。")]),a._v(" "),t("h3",{attrs:{id:"内存分配策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配策略"}},[a._v("#")]),a._v(" 内存分配策略")]),a._v(" "),t("ol",[t("li",[a._v("对象优先在 Eden 分配")])]),a._v(" "),t("p",[a._v("大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。")]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("大对象直接进入老年代")])]),a._v(" "),t("p",[a._v("大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。")]),a._v(" "),t("p",[a._v("-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。")]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("长期存活的对象进入老年代")])]),a._v(" "),t("p",[a._v("为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。")]),a._v(" "),t("p",[a._v("-XX:MaxTenuringThreshold 用来定义年龄的阈值，默认值为15。")]),a._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[a._v("动态对象年龄判定")])]),a._v(" "),t("p",[a._v("虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。")]),a._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[a._v("空间分配担保")])]),a._v(" "),t("p",[a._v("在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。")]),a._v(" "),t("p",[a._v("如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。")])])}),[],!1,null,null,null);r.default=s.exports}}]);