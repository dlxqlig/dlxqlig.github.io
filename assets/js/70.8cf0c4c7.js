(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{766:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("世界上第一种计算机高级语言是诞生于1954年的FORTRAN语言。之后出现了多种计算机高级语言。1970年，AT&T的Bell实验室的D.Ritchie和K.Thompson共同发明了C语言。研制C语言的初衷是用它编写UNIX系统程序，因此，它实际上是UNIX的“副产品”。它充分结合了汇编语言和高级语言的优点，高效而灵活，又容易移植。")]),t._v(" "),s("h2",{attrs:{id:"左值引用和右值引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#左值引用和右值引用"}},[t._v("#")]),t._v(" 左值引用和右值引用")]),t._v(" "),s("h3",{attrs:{id:"左值引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#左值引用"}},[t._v("#")]),t._v(" 左值引用")]),t._v(" "),s("p",[t._v("常规引用，一般表示对象的身份。")]),t._v(" "),s("h3",{attrs:{id:"右值引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#右值引用"}},[t._v("#")]),t._v(" 右值引用")]),t._v(" "),s("p",[t._v("右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。\n右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：")]),t._v(" "),s("p",[t._v("消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。\n能够更简洁明确地定义泛型函数。")]),t._v(" "),s("h2",{attrs:{id:"成员初始化列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#成员初始化列表"}},[t._v("#")]),t._v(" 成员初始化列表")]),t._v(" "),s("p",[t._v("更高效：少了一次调用默认构造函数的过程。\n有些场合必须要用初始化列表：\n常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面\n引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面\n没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化")]),t._v(" "),s("h2",{attrs:{id:"explicit（显式）关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#explicit（显式）关键字"}},[t._v("#")]),t._v(" explicit（显式）关键字")]),t._v(" "),s("p",[t._v("explicit 修饰构造函数时，可以防止隐式转换和复制初始化\nexplicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外")]),t._v(" "),s("h2",{attrs:{id:"struct-和-class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-和-class"}},[t._v("#")]),t._v(" struct 和 class")]),t._v(" "),s("p",[t._v("struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。")]),t._v(" "),s("p",[t._v("区别:\n最本质的一个区别就是默认的访问控制\n默认的继承访问权限。struct 是 public 的，class 是 private 的。\nstruct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。")]),t._v(" "),s("h2",{attrs:{id:"volatile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" volatile")]),t._v(" "),s("p",[t._v("volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\nvolatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）\nconst 可以是 volatile （如只读的状态寄存器）\n指针可以是 volatile")]),t._v(" "),s("h2",{attrs:{id:"inline-内联函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inline-内联函数"}},[t._v("#")]),t._v(" inline 内联函数")]),t._v(" "),s("p",[t._v("相当于把内联函数里面的内容写在调用内联函数处；\n相当于不用执行进入函数的步骤，直接执行函数体；\n相当于宏，却比宏多了类型检查，真正具有函数特性；\n编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；\n在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。")]),t._v(" "),s("h2",{attrs:{id:"static"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("#")]),t._v(" static")]),t._v(" "),s("p",[t._v("修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\n修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。")]),t._v(" "),s("h2",{attrs:{id:"虚析构函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数"}},[t._v("#")]),t._v(" 虚析构函数")]),t._v(" "),s("p",[t._v("虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。")]),t._v(" "),s("h2",{attrs:{id:"虚函数、纯虚函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚函数、纯虚函数"}},[t._v("#")]),t._v(" 虚函数、纯虚函数")]),t._v(" "),s("p",[t._v("类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。\n虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。\n虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。\n带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。\n虚基类是虚继承中的基类，具体见下文虚继承。")]),t._v(" "),s("h2",{attrs:{id:"内存分配和管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存分配和管理"}},[t._v("#")]),t._v(" 内存分配和管理")]),t._v(" "),s("p",[t._v("malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。\ncalloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。\nrealloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。")]),t._v(" "),s("h2",{attrs:{id:"定位-new"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定位-new"}},[t._v("#")]),t._v(" 定位 new")]),t._v(" "),s("p",[t._v("定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。\nnew (place_address) type")]),t._v(" "),s("h2",{attrs:{id:"强制类型转换运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制类型转换运算符"}},[t._v("#")]),t._v(" 强制类型转换运算符")]),t._v(" "),s("p",[t._v("static_cast\n用于非多态类型的转换\n不执行运行时类型检查（转换安全性不如 dynamic_cast）\n通常用于转换数值数据类型（如 float -> int）\n可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）")]),t._v(" "),s("p",[t._v("dynamic_cast\n用于多态类型的转换\n执行行运行时类型检查\n只适用于指针或引用\n对不明确的指针的转换将失败（返回 nullptr），但不引发异常\n可以在整个类层次结构中移动指针，包括向上转换、向下转换")]),t._v(" "),s("h2",{attrs:{id:"tcp-与-udp-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-与-udp-的区别"}},[t._v("#")]),t._v(" TCP 与 UDP 的区别")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("CP 面向连接，UDP 是无连接的；\nTCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付\nTCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道\n每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信\nTCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）\nUDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）\nTCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节\n")])])]),s("h2",{attrs:{id:"tcp-黏包问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-黏包问题"}},[t._v("#")]),t._v(" TCP 黏包问题")]),t._v(" "),s("p",[t._v("TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。\n包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。\n在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。\n使用更加复杂的应用层协议。\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);